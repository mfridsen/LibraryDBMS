@Test
@Order(<Test_Number>)
void test<MethodName>_<TestCase>()
{
    System.out.println("\n<Test_Number>: Testing <MethodName> method with <explanation of test case>...");


    System.out.println("\nTEST FINISHED.");
}

Example:

/**
 * Javadoc providing a brief description of what the method tests.
 */
@Test
@Order(7)
void testSetup_EmptyDatabase()
{
    System.out.println("\n7: Testing setup method with an empty database...");

    // Call the setup method
    UserHandler.setup();

    // Verify that the storedTitles and availableTitles maps are empty
    assertEquals(0, UserHandler.getStoredUsernames().size(), "storedUsernames list should be empty after setup with an empty database");

    System.out.println("\nTEST FINISHED.");
}

If exceptions can be thrown, all non-asserted methods should be handled by placing the entire test in a try-catch
block and failing like so:

    /**
     * Test case for the setPublisherName method with valid data.
     * This test checks if the setPublisherName method correctly sets the publisherName.
     */
    @Test
    @Order(3)
    void testSetPublisherName_ValidData()
    {
        System.out.println("\n3: Testing setPublisherName method with valid data...");

        try {
            Publisher publisher = new Publisher("Test Publisher");
            String validName = "Valid Publisher";
            publisher.setPublisherName(validName);
            assertEquals(validName, publisher.getPublisherName(),
                         "Publisher name must be the same as the one set");
        } catch (InvalidNameException | ConstructionException e) {
            e.printStackTrace();
            fail("Valid operations should not throw exceptions.");
        }

        System.out.println("\nTEST FINISHED.");
    }

For Model classes, create one test class per constructor and then one for the setters.

Example:

/**
 * Javadoc providing brief description of what the class tests.
 /*
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class AuthorCreationTest
{

    /**
     * Javadoc providing a brief description of what the method tests.
     */
    @Test
    @Order(1)
    void testAuthorCreation_ValidData()
    {

    }
}

AuthorRetrievalTest
AuthorCopyTest
AuthorSettersTest



For Control classes (named <ModelClassName>Handler), create one test class per one major method in the Handler, named
like so:

/**
 * Javadoc providing brief description of what the class tests.
 /*
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class CreateItemTest
{
    /**
     * Javadoc providing a brief description of what the method tests.
     */
    @Test
    @Order(1)
    void testCreateItem_ValidData()
    {

    }
}

Remember to test ALL the fields are set correctly in the ValidData tests, both declared AND inherited!
Remember to test Strings for null, empty and length, where applicable.
Remember to test IDs where applicable.
Remember to test causes of exceptions where applicable.

For utility methods and generally short methods we can create one or two classes depending on circumstances.
For instance, if we have a setup() method, which I usually do, at the very top of the class, that method and the methods
it calls should be tested in one test class, and any other utility methods found at the bottom of the class should be
covered by another test class.